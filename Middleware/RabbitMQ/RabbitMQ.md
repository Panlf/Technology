#  RabbitMQ

## 消息中间件概念

### 消息中间件应用的场景

- 跨系统数据传递
- 高并发的流量削峰
- 数据的分发和异步处理
- 大数据分析与传递

比如你有一个数据要进行迁移或者请求并发过多的时候，比如你有10W的并发请求下订单，我们可以在这些订单入库之前，我们可以把订单请求堆积到消息队列中，让它稳健可靠的入库和执行。

### 消息中间件的核心组成部分

- 消息的协议
- 消息的持久化机制
- 消息的分发策略
- 消息的高可用，高可靠
- 消息的容错机制

### 消息协议

消息中间件采用的并不是http协议，而常见的消息中间件协议有：OpenWire、AMQP、MQTT、Kafka、OpenMessage协议

>  面试题：为什么消息中间件不直接使用http协议呢？
>
> 1、因为http请求报文头和响应报文头是比较复杂的，包含了cookie，数据的加密解密，状态码等附加的功能，但是对于一个消息而言，我们并不需要这么复杂，也没有这个必要性，它其实就是负责数据传递、存储、分发就行，一定要追求的是高性能。尽量简洁和快速。
>
> 2、大部分情况下http大部分是短链接，在实际的交互过程中，一个请求到响应很有可能会中断，中断以后就不会持久化，就会造成请求的丢失。这样就不利于消息中间件的业务场景，因为消息中间件可能是一个长期的获取消息的过程，出现问题和故障要对数据或消息进行持久化等，目的就是为了保证消息和数据的高可用和稳健的运行。

#### AMQP协议

高级消息队列协议，是一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件涉及。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件限制。

特性

- 分布式事务支持
- 消息的持久化支持
- 高性能和高可靠的消息处理优势

#### MQTT协议

即时通讯协议，物联网系统架构中的重要组成部分

特点

- 轻量
- 结构简单
- 传输快，不支持事务
- 没有持久化设计

应用场景

- 适用于计算能力有限
- 低带宽
- 网络不稳定的场景

#### OpenMessage协议

分布式消息中间件、流处理等领域的应用开发标准。

特点

- 结构简单
- 解析速度快
- 支持事务和持久化设计

#### Kafka协议

基于TCP/IP的二进制协议。消息内部是通过长度来分割，由一些基础数据类型组成。

特点

- 结构简单
- 解析速度快
- 无事务支持
- 有持久化设计

### 消息分发策略

- 发布订阅
- 轮询分发
- 公平分发
- 重发
- 消息拉取

### 高可用模式

#### Master-Slave主从共享数据的部署方式

生产者讲消费发送到Master节点，所有的都连接这个消息队列共享这块数据区域，Master节点负责写入，一旦Master挂掉，slave节点继续服务，从而形成高可用。

#### Master-Slave主从同步部署方式

这种模式写入消息同样在Master主节点上，但是主节点会同步数据到slave节点形成副本，和zookeeper或者redis主从机制很类同。这样可以达到负载均衡的效果，如果消费者有多个这样就可以去不同的节点进行消费，以为消息的拷贝和同步会占用很大的带宽和网络资源。

#### 多主集群同步部署模式

和上面的区别不是特别的大，但是它的写入可以往任意节点去写入。

#### 多主集群转发部署模式

如果你插入的数据是broker-1中，元数据信息会存储数据的相关描述和记录存放的位置（队列）。

它会对描述信息也就是元数据信息进行同步，如果消费者在broker-2中进行消费，发现自己几点没有对应的消息，可以从对应的元数据信息中去查询，然后返回对应的消息信息，场景：比如买火车票或者黄牛买演唱会门票，比如第一个黄牛有顾客说要买的演唱会门票。但是没有但是他会去联系其他的黄牛询问，如果有就返回。

#### Master-Slave与Broker-Cluster组合的方案

实现多主多从的热备机制来完成消息的高可用以及数据的热备机制，在生产规模达到一定的阶段的时候，这种使用的频率比较高。

**总结**

- 要么消息共享
- 要么消息同步
- 要么元数据共享



## RabbitMQ安装

### Docker安装

```shell
# 获取rabbit镜像
docker pull rabbitmq:management

# 创建并运行容器
docker run -di --name=myrabbit -p 15672:15672 rabbitmq:management

docker run -di --name myrabbit -e \n 
RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin \n
-p 15672:15672 -p 25672:25672 -p 61613:61613 -p 1883:1883 rabbitmq:management

# 查看日志
docker logs -f myrabbit

# 启动/停止
systemctl start rabbitmq-server
systemctl stop rabbitmq-server
```

## RabbitMQ的角色分类

### none

- 不能访问management plugin

### management 查看自己相关节点信息

- 列出自己可以通过AMQP登入的虚拟机
- 查看自己的虚拟机节点 virtual hosts的queues、exchanges和bindings信息
- 查看和关闭自己的channels和connections
- 查看有关自己的虚拟机节点virtual hosts的统计信息。包括其他用户在这个节点virtual hosts中的活动消息

### Policymaker

- 包含management所有权限
- 查看和创建和删除自己的virtual hosts所属的policies和parameters信息

### Monitoring

- 包含management所有权限
- 罗列出所有的virtual hosts，包括不能登录的virtual hosts.
- 查看节点级别的数据如clustering和memory使用情况
- 查看所有的virtual hosts的全局统计信息

### Administrator

- 最高权限
- 可以创建和删除virtual hosts
- 可以查看，创建和删除users
- 查看创建permissions
- 关闭所有用户的connections

## RabbitMQ核心组成部分

- Server ： 又称Broker，接受客户端的连接，实现AMQP实体服务。安装rabbitmq-server
- Connection ：连接，应用程序与Broker的网络连接 TCP/IP 三次握手和四次挥手
- Channel ：网络信道，几乎所有的操作都在Channel中进行，Channel是进行消费读写的通道，客户端可以建立对各Channel，每个Channel代表一个会话任务。
- Message：消息。服务与应用程序之间传送的数据，由Properties和Body组成，Properties可是对消息进行修饰，比如消息的优先级，延迟等高级特性，Body则就是消息体的内容。
- Virtual Host ：虚拟地址，用于进行逻辑隔离，最上层的消息路由，一个虚拟主机理由可以有若干个Exchange和Queueu，同一个虚拟主机里面不能有相同名字的Exchange
- Exchange ：交换机，接受消息，根据路由键发送消息到绑定的队列。（==不具备消息存储的能力==）
- Bindings ：Exchange和Queue之间的虚拟连接，binding中可以保护多个routing key
- Routing key ：路由规则，虚拟机可以用它来确定如何路由一个特定的消息
- Queue ：队列，也成为Message Queue，消息队列，保存消息并将它们转发给消费者。

## RabbitMQ运行流程

```
Producer
	业务数据 ---可能的序列化---> 序列化之后的消息 ---指定Exchange和Routing Key等，即为消息添加Label---> 消息
	
	---发送到Broker---> Broker ---Consumer订阅并接收消息--->

Consumer	
	消息 ---可能的反序列化---> 反序列化之后的数据 ------> 接收的业务方数据 ------> 业务处理
```

## RabbitMQ模式

- 简单模式
- Fanout模式   
  - 发布与订阅模式，是一种广播就机制，他是没有路由key的模式
- Direct模式
  - 路由模式，有routing-key的匹配模式
- Topic模式
  - 主题模式，模糊的routing-key的匹配模式
- Headers模式
  - 参数模式，参数匹配模式
- Work模式
  - 分发机制： 轮询分发 、公平分发



## RabbitMQ使用场景

- 削峰
- 异步
- 解耦



## RabbitMQ高级

### 过期时间TTL

过期时间TTL表示可以对消息设置预期的时间，在这个时间内都可以被消费者接收获取；过了之后消息将自动删除。RabbitMQ可以对消息队列设置TTL。

- 通过队列属性设置，队列中的所有消息都有相同的过期时间
- 对消息单独设置，每条消息TTL都可以不同



### 死信队列

DLX，可以被称为死信交换机，也有人称死信邮箱，当消息在一个队列中变成死信之后，它能被重新发送到另一个交换机中，这个交换机就是DLX，绑定DLX的队列就称之为私信队列。消息变成死信，可能原因如下：

- 消息被拒绝
- 消息过期
- 队列达到最大长度

DLX也是一个正常的交换机，和一般的交换机没有区别，它能在任何的队列上被指定，实际上就是设置某一个队列的属性。当这个队列中存在死信时，RabbitMQ就会自动将这个消息重新发布到设置的DLX上去，进而被路由到另一个队列，即死信队列。

要想使用死信队列，只需要在定义队列的时候设置队列参数，`x-dead-letter-exchange`指定交换机即可。



## RabbitMQ的问题分析

### RabbitMQ为什么需要信道，为什么不是TCP直接通信

- TCP的创建和销毁，开销大，创建要三次握手，销毁要四次分手
- 如果不用信道，那应用程序就会TCP连接到Rabbit服务器，高峰时每秒成千上万连接就会造成资源的巨大浪费，而且底层操作系统每秒处理tcp连接数也是有限制的，必定造成性能瓶颈
- 信道的原理是一条线程一条信道，多条线程多条信道同用一条TCP连接，一条TCP连接可以容忍无限的信道，即使每秒成千上万的请求也不会成为瓶颈。

### Queue队列到底是消费者创建还是生产者创建

- 一般建议是在rabbitmq操作面板创建。
- 按照常理来说，确实应该消费者这边创建是最好，消息的消费是在这边。这样你承受一个后果，可能我生产在生产消息可能会丢失消息
- 在生产者创建队列也是可以的，这样稳妥的方法，消息是不会出现丢失
- 如果你生产者和消费者都创建的队列，谁先启动谁先创建，后面启动就覆盖前面的

### 解决消息重试的集中方案

- 控制重发的次数 + 死信队列
- try + catch + 手动ack
- try + catch + 手动ack + 死信队列处理 + 人工干预

## 分布式事务

### 优点

- 通用性强
- 拓展方便
- 耦合度低，方案也比较成熟

### 缺点

- 基于消息中间件，只适合异步场景
- 消息会延迟处理，需要业务上能够容忍

### 建议

- 尽量去避免分布式事务
- 尽量将非核心业务做成异步
