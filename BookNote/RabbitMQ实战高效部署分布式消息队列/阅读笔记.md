# RabbitMQ实战 高效部署分布式消息队列

## 理解消息通信
### 消费者和生产者

生产者创键消息，消费者接收这些消息。你的应用程序可以作为生产者，向其他应用程序发送消息，向其他应用程序发送消息。或者作为一个消费者，接收消息。也可以在两者之间进行切换。不过在此之前，它必须先建立一条信道（channel）。

你必须首先连接到Rabbit，才能消费或者发布消息。你的应用程序和Rabbit代理服务器之间创键一条TCP连接。一旦TCP连接打开（你通过了认证），应用程序就可以创建一条AMQP信道。信道是建立在“真实的”TCP连接内的虚拟连接。AMQP命令都是通过信道发送出去的。每条信道都会被指派一个唯一ID（AMQP库会帮你记住ID的）。不论是发布消息、订阅队列或是接收消息，这些动作都是通过信道完成的。你也许会问为什么我们需要信道呢？为什么不直接通过TCP连接发送AMQP命令呢？主要原因在于对操作系统来说建立和销毁TCP会话是非常昂贵的开销。假设应用程序从队列消费消息，并根据服务需求合理调度线程。假设你只进行TCP连接，那么每个线程都需要自行连接到Rabbit。也就是说高峰期有每秒成百上千条连接。这不仅造成TCP连接的巨大浪费，而且操作系统每秒也就只能建立这点数量的连接。因此，你可能很快就碰到性能瓶颈了。如果我们为所有线程只使用一条TCP连接以满足性能方面的要求，但又能确保每个线程的私密性，就像拥有独立连接一样的话，那不就非常完美吗？这就是要引人信道概念的原因。线程启动后，会在现成的连接上创建一条信道，也就获得了连接到Rabbit上的私密通信路径而不会给操作系统的TCP栈造成额外负担。因此，你可以每秒成百上千次地创建信道而不会影响操作系统。在一条TCP连接上创建多少条信道是没有限制的。把它想象成一束光纤电缆就可以了。

### 队列

AMQP消息路由必须有三部分：交换器、队列和绑定。生产者把消息发布到交换器上；消息最终达到队列，并被消费者接收；绑定决定了消息如何从路由器路由到特定的队列。

队列是AMQP消息通信的基础模块
- 为消息提供了处所，消息在此等待消费
- 对负载均衡来说，队列是绝佳方案。只需附加一堆消费者，并让RabbitMQ以循环的方式均匀地分配发来的消息。
- 队列是Rabbit中消息的最后的终点

### 交换器和绑定
当你想要将消息投递到队列时，你通过把消息发送给交换器来完成。然后根据确定的规则，RabbitMQ将会决定消息该投递到哪个队列。这些规则被称作路由键（routing key）。队列通过路由键绑定到交换器。

服务器会根据路由键将消息从交换器路由到队列，一共有四种类型：direct、fanout、topic和headers。headers交换器允许你匹配AMQP消息的header而非路由键。除此之外，headers交换器和direct交换器完全一致，但是性能会差很多，因此它并不太实用，而且几乎再也用不到了。

- direct交换器非常简单：如果路由键匹配的话，消息就被投递到对应的队列。
- fanout交换器：这种类型的交换会将收到的消息广播到绑定的队列上。消息通信模式很简单：当你发送一条消息到fanout交换器时，它会把消息投递给所有附加在此交换器上的队列。这允许你对单条消息做不同方式的反应。
- topic交换器：这类交换器使得来自不同源头的消息能够到达同一个队列。

总结
- AMQP架构中最关键的几个组件分别是交换器、队列和绑定
- 根据绑定规则将队列绑定到交换器上
- 消息是发布到交换器上的
- 有三种类型的交换器：direct、fanout和topic
- 基于消息的路由键和交换器类型，服务器会决定将消息投递到哪个队列去。

## 多租户：虚拟主机和隔离
每一个RabbitMQ服务器都能创键虚拟消息服务器，我们称之为虚拟主机（vhost）。每一个vhost本质上是一个mini版的RabbitMQ服务器，拥有自己的队列、交换器和绑定，更重要的是，它拥有自己的权限机制。

vhost是AMQP概念的基础，你必须在连接时进行指定。由于RabbitMQ包含了开箱即用的默认vhost：“/”，因此使用起来非常简单。如果你不需要多个vhost的话，那么就使用默认的把。通过使用缺省的guest用户名和密码guest就可以访问默认vhost。

当你在Rabbit里创键一个用户时，用户通常会被指派给至少一个vhost，并且只能访问被指派vhost内的队列、交换器和绑定。当你在设计消息通信架构时，记住vhost之间是绝对隔离的，事实上，这既保证了安全性，又确保了可移植性。

我们强烈推荐你仔细甄别基础架构中通用功能群组，并为它们分别分配各自的vhost，同时，请记住，当你在RabbitMQ集群上创键vhost时，整个集群上都会创建该vhost。vhost不仅消除了为基础架构中的每一层运行一个RabbitMQ服务器的需要，同样也避免了为每一层创键不同集群。

## 持久化
如果消息想要从Rabbit崩溃中回复，那么消息必须
- 把它的投递模式选项设置为持久
- 发送到持久化的交换器
- 到达持久化的队列

RabbitMQ确保持久性消息能从服务器重启中恢复的方式是，将它们写入磁盘上的一个持久化日志文件。当发布一条持久性消息到持久交换器上时，Rabbit会在消息提交到日志文件后才发送响应。记住，之后这条消息如果路由到了非持久队列的话，它会自动从持久性日志中移除，并且无法从服务器重启中恢复。如果你使用持久性消息的话，则确保之前提到的持久性消息的那三点都必须做到位。一旦你从持久化队列中消费了一条持久性消息的话，RabbitMQ 会在持久化日志中把这条消息标记为等待垃圾收集。在你消费持久性消息前,如果 RabbitMQ 重启的话,服务器会自动重建交换器和队列以及绑定，重播持久性日志文件中的消息到合适的队列或者交换器上（取决于Rabbit服务器宕机的时候，消息处在路由过程的哪个环节）。

## 运行和管理Rabbit
### 服务器管理
- 启动节点
- 停止节点

### 管理用户
在RabbitMQ中，用户是访问控制的基本单元。针对一到多个vhost，其可以被赋予不同级别的访问权限，并使用标准的用户名和密码来认证用户。

每一条访问控制条目由以下四部分组成
- 被授予访问权限的用户
- 权限控制应用的vhost
- 需要授予的读/写/配置权限的组合
- 权限范围

访问控制条目是无法跨越vhost的。

### 查看数据统计
- 列出队列和消息数目
- 查看交换器和绑定

## 编码与模式
### 谁将我们推向消息通信
- 异步状态思维（分离请求和动作）
- 提供扩展性：没有负载均衡器的世界
- 零成本API：语言不应称为枷锁

### 发后即忘模型
- 发送告警
- 并行处理

### 用RabbitMQ实现RPC并等待响应
- 私有队列和发送确认
- 使用reply_to来实现简单的JSON RPC

## 集群并处理失败
### 集群架构
- 集群中的队列
- 分布交换器
- 是内存节点还是磁盘节点

### 镜像队列和保留消息
- 声明并使用镜像队列
- 镜像队列工作原理

## 从故障中恢复
### 为Rabbit做负载均衡
- 安装HAProxy
- 配置HAProxy

### 连接丢失和故障转移

## 故障转移和复制
### warren：另一种集群方式
### 设定负载均衡-基于主/从的集群
### 远距离通信和复制
- Shovel

## 从Web端管理RabbitMQ
### RabbitMQ Management插件
### 从Web控制台来管理RabbitMQ
- 监控Erlang VM
- 从JSON文件导入配置

### 从Web控制台管理用户
- 创键用户
- 管理用户权限

### 从Web控制台管理交换器和队列
- 列出队列信息
- 创键队列

## 使用Rest API控制Rabbit
### 对客户端授权访问
### 访问数据统计
### 自动化vhost和用户配置

## 监控
### 监控warren
- 为Nagios编写健康监测
- 使用AMQP模拟监测来确认RabbitMQ是否运行
- 使用Rest Api来监测
- 监控配置文件修改
- 监控集群状态
### 确保消费者正常工作
- 通过AMQP监控队列等级
- 使用Rest Api来监控队列级别
- 建立队列的消息计数基准经验发着

## 提升性能，保障安全
### 对速度的需求
- 消息持久化
- 消息确认
- 路由算法和绑定规则
- 投递消息

### 内存使用率和进程限制
- 内存使用率
- Erlang进程计数

### SSL连接
