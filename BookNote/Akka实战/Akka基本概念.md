## Akka

> Akka是一款 高性能、高容错性的分布式&并行应用框架，遵循Apache2开源许可，底层通过JVM上另外一个流行的语言Scala实现，提供Java&Scala API。

特点

- 并行与并发	提供对并行与并发的高度抽象
- 异步非阻塞   Akka-Actor 消息通信都是基于异步非阻塞
- 高容错性  为跨多JVM的分布式模型提供强劲的容错处理，号称永不宕机
- 持久化  Actor携带的状态或消息可以被持久化，以便于在JVM崩溃后能恢复状态
- 轻量级  每个Actor大约只占300bytes，即1G内存可容纳接近300万个Actor

应用场景

- 服务后端  比如rest web、websocket 服务、分布式消息计算
- 并发&并行 比如日志异步处理，密集数据计算。
- 对高并发和密集计算的系统，Akka都是适用的

### 架构体系

#### Actor模型  

Actor模型认为，并行计算的最小单元就是一个Actor实例，而每个实例拥有自己的状态和行为，在一个大型系统中，可能存在成千上万个Actor实例，他们之间通过消息的方式通信，每个Actor都能发送消息给其他Actor，也能从其他Actor接收消息。

### Actor组件

#### Akka中的Actor

Actor提供良好易用的问答式API来进行消息的通信，并且理论上不限制任何类型的消息，他们可以是字符串、对象，但是为了保证消息的对象不受意外修改，最好使用不变类型的对象。

- 线程安全
- 轻量级

#### ActorSystem

在一个应用中，所有的Actor共同构成了Actor系统，即ActorSystem。一般来讲，我们所用的Actor都可能有一个显式的父级Actor（除顶级Actor外），他会处理所有自己子孙失败的情况。

比较常见的场景是：当子Actor在处理消息时出现了异常情况，父Actor可以通过匹配预先设定的某个动作来处理子Actor，处理方式有：恢复子级、重启子级、停止子级、重启子级、停止子级、扩大化失败，这就是所谓的“父监督”模式。

#### 生命周期监控

Actor提供了生命周期管理的API，比如`preStart`、`preRestart`、`postRestart`、`postStop`等，当前这个Actor到底处于什么状况。

#### 引用与路径

Actor不同于一般的Java对象，它既可能存在于本地，也可能存在于远程，但是对使用者来讲并没有明显的区分，仅仅只需要操作它的引用对象就行了，在Akka中，使用ActorRef来表示一个Actor的引用。

ActorRef对原生的Actor实例做了良好的封装（也可以理解为一种代理），外界不能随意修改其内部状态，并且只能通过统一的方式去操作一个Actor。

每个Actor在被创建后都拥有自己的路径，该路径遵循ActorSystem的层级结构。如果是远程Actor，则需要给出IP和端口。通过路径，我们可以很方便地查找到一个Actor。























































