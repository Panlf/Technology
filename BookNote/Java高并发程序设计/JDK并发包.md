# JDK并发包

## 同步控制

### 重入锁

```
lock.lock();
lock.lock();
try{
    i++;
} finally {
    lock.unlock();
    lock.unlock();
}
```

在这种情况下，一个线程连续两次获得同一把锁是允许的。如果不允许这么操作，那么同一个线程在第2次获得锁时，将会和自己产生死锁。


**中断响应**

对于关键字synchronized来说，如果一个线程在等待锁，那么结果只有两种结果，要么它获得这把锁继续执行，那么它就保持等待。而使用重入锁，则提供另外一种可能，那就是线程可以被中断。


**锁申请等待限时**

除了等待外部通知之外，要避免死锁还有另外一种方法，那就是限时等待。

**公平锁**

在大多数情况下，锁的申请都是非公平的。系统只是会从这个锁的等待队列中随机挑选一个。因此不能保证其公平性。而公平的锁，则不是这样，它会按照时间的先后顺序，保证先到先得，后到者后得。公平锁的一大特点是：它不会产生饥饿现象。

ReentrantLock几个重要方法整理
- lock()：获得锁，如果锁已经被占用，则等待
- lockInterruptibly()：获得锁，但优先响应中断
- tryLock()：尝试获得锁，如果成功，则返回true，失败返回false。该方法不等待，立即返回
- tryLock(long time,TimeUnit unit)：在给定时间内尝试获得锁
- unlock：释放锁

在重入锁的实现中，主要包含三个要素：
- 原子状态：原子状态使用CAS操作来存储当前锁的状态，判断锁是否已经被别的线程持有了。
- 等待队列。所有没有请求到锁的线程，会进入等待队列进行等待。待有线程释放锁后，系统就能从等待队列中唤醒一个线程，继续工作。
- 阻塞原语park()和unpark(),用来挂起和恢复线程。没有得到锁的线程将会被挂起。

### Condition

- await()方法会使当前线程等待，同时释放当前锁，当其他线程中使用signal()方法或者signalAll()方法时，线程会重新获得锁并继续执行。或者当线程被中断时，也能跳出等待。这和Object.wait()方法相似。
- awaitUninterruptibly()方法与await()方法基本相同，但是它并不会在等待过程中响应中断。
- singal()方法用于唤醒一个在等待中的线程，singalAll()方法会唤醒所有在等待中的线程。这和Object.notify()方法很类似。

与Object.wait()方法和notify()方法一样。当线程使用Condition.await()方法时，要求线程持有相关的重入锁，在Condition.await()方法调用后，这个线程会释放这把锁。同理，在Condition.signal()方法调用时，也要求线程先获得相关的锁。在signal()方法调用后，系统会从当前Condition对象的等待队列中唤醒一个线程。一旦线程被唤醒，它会重新尝试获得与之绑定的重入锁，一旦成功获取，就可以继续执行了。因此，在signal()方法调用之后，一般需要释放相关的锁，让给被唤醒的线程，让它可以继续执行。

### 信号量（Semaphore）

信号量为多线程协作提供了更为强大的控制方法。从广义上说，信号量是对锁的扩展。无论是内部锁synchronized还是重入锁ReentrantLock，一次都只允许一个线程访问一个资源，而信号量却可以指定多个线程，同时访问某一个资源。

### ReadWriteLock读写锁

读写分离锁可以有效地帮助减少锁竞争，提升系统性能。用锁分离的机制来提升性能非常容易理解，比如线程A1、A2、A3进行写操作，B1、B2、B3进行读操作，如果使用重入锁或者内部锁，从理论上说所有读之间、读与写之间、写和写之间都是串行操作。当B1进行读取时，B2、B3则需要等待锁。由于读操作并不对数据的完整性造成破坏，这种等待显然时不合理的。

- 读-读不互斥：读读之间不阻塞
- 读-写互斥：读阻塞写，写也会阻塞读
- 写-写互斥：写写阻塞

### 倒计数器（CountDownLatch）
CountDownLatch是一个非常实用的多线程控制工具类。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计数结束，再开始执行。

### 循环栅栏（CyclicBarrier）

CyclicBarrier是另外一种多线程并发控制工具。CyclicBarrier可以理解为循环栅栏。这个计数器可以反复使用。比如我们将计数器设置为10，那么凑齐第一批10个线程后，计数器就会归零，接着凑齐下一批10个线程，这就是循环栅栏内在的含义。

### 线程阻塞工具类（LockSupport）

LockSupport是一个非常方便实用的线程阻塞工具，它可以在线程内任意位置让线程阻塞。与Thread.suspend()方法相比，它弥补了由于resume()方法发生导致线程无法继续执行的情况。和Object.wait()方法相比，它不需要先获得某个对象的锁，也不会抛出InterrupteException异常。

LockSupport的静态方法park()可以阻塞当前线程，类似的还有parkNanos()、parkUntil()等方法，它们实现了一个限时的等待。

## JDK的并发容器

- ConcurrentHashMap：这是一个高效的并发HashMap。你可以把它理解为一个线程安全的HashMap。
- CopyOnWriteArrayList：这是一个List，从名字看就直到它和ArrayList是一族的。在读多写少的场合，这个List的性能非常好，远远优于Vector。
- ConcurrentLinkedQueue：高效的并发队列，使用链表实现。可以看作一个线程安全的LinkedList。
- BlockingQueue：这是一个接口，JDK内部通过链表、数组等方式实现了这个接口，表示阻塞队列，非常适合作为数据共享的通道。
- ConcurrentSkipListMap：跳表的实现。这是一个Map，使用跳表的数据结构进行快速查找。