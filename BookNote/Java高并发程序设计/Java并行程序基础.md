# Java并行程序基础

## 线程的基本操作

### 新建线程

```
Thread t1 = new Thread();
t1.start();
```

注意：不要`run()`方法来开启新线程。它只会在当前线程中串行执行`run()`方法中的代码。

### 终止线程

`Thread.stop()`方法在结束线程时，会直接终止线程，并立即释放这个线程所持有的锁，而这些锁恰恰是用来维持对象的一致性。如果此时，写线程写入数据正写到一半，并强行终止，那么对象就会被写坏，同时，由于锁已经释放，另外一个等待该锁的读线程就顺理成章地读到了这个不一致的对象。

### 线程中断

严格来讲，线程中断并不会使线程立即退出，而是给线程发送一个通知，告知目标线程，有人希望你退出啦！至于目标线程接到通知后如何处理，则完全由目标线程自行决定。

```
public void run() {
    while(true){
        if(Thread.currentThread().isInterrupted()){
            System.out.println("Interrupted");
            break;
        }
        try{
            Thread.sleep(2000);
        } catch (InterruptedException e){
            System.out.println("Interrupted When Sleep");
            //设置中断状态
            Thread.currentThread().interrupt();
        }
        // 提示当前正在执行的线程让出 CPU 资源，
        // 使当前线程从运行状态变为就绪状态，以便同优先级的其他线程有机会执行。
        Thread.yield();
    }
}
```
Thread.sleep()方法由于中断而抛出异常，此时，它会清除中断标记，如果不加处理，那么在下一次循环开始时，就无法捕获这个中断，故在异常处理中再次设置中断标记位。

### 等待（wait）和通知（notify）
当在一个对象实例上调用wait()方法后，当前线程就会在这个对象上等待。比如，在线程A中，调用了obj.wait()方法，那么线程A就会停止继续执行，转为等待状态。线程A会一直等到其他线程调用obj.notify()方法为止。这时，object对象成了多个线程之间的有效通信手段。

### 挂起（suspend）和继续执行（resume）线程

不推荐使用suspend()方法区挂起线程是因为suspend()方法在导致线程暂停的同时，并不会释放任何锁资源。此时，其他任何线程想要访问被它占用的锁时，都会被牵连，导致无法正常继续运行。直到对应的线程上进行了resume()方法操作，被挂起的线程才能继续，从而其他所有阻塞在相关锁上的线程也可以继续执行。但是，如果resume()方法操作意外地在suspend()方法前就执行了，那么被挂起的线程可能很难有机会被继续执行。并且，更严重的是：它所占用的锁不会被释放，因此可能会导致整个系统工作不正常。而且，对于被挂起的线程，从它的线程状态上看，居然还是Runnable，这也会严重影响我们对系统当前状态的判断。

### 等待线程结束（join）和谦让（yeild）

join()方法的本质是让调用线程wait()方法在当前线程对象实例上。join()方法实现的核心代码片段
```
while(isAlive()){
    wait(0);
}
```

```
public static native vpod yield();
```
这是一个静态方法，一旦执行，它会使当前线程让出CPU。但要注意，让出CPU并不表示当前线程不执行了，当前线程在让出CPU后，还会进行CPU资源的争夺，但是是否能够再次被分配到就不一定了。

## volatile

当你用关键字volatile声明一个变量时，就等于告诉了虚拟机，这个变量极有可能会被某些程序或者线程修改。为了确保这个变量被修改后，应用程序范围内的所有线程都能够看到这个改动，虚拟机就必须采用一些特殊的手段，保证这个变量的可见性等特点。

## 线程组

在一个系统中，如果线程数量很多，而且功能分配比较明确，就可以将相同功能的线程放置在同一个线程组里。

## 守护线程（Daemon）
守护线程是一种特殊的线程，在后台默默完成一些系统性的服务，比如垃圾回收线程、JIT线程就可以理解为守护线程。

## 线程优先级
Java中的线程可以有自己的优先级。优先级高的线程在竞争资源时会更有优势，更可能抢占资源，当然，这只是一个概率问题。如果运气不好，那么高优先级线程可能也会抢占失败。
```
# 使用1到10表示线程优先级
Thread.setPriority(1);
```

## synchronized

关键字synchronized的作用是实现线程间的同步。它的工作是对同步的代码加锁，使得每一次，只能有一个线程进入同步块，从而保证线程间的安全性。

关键字synchronized可以有多种用法
- 指定加锁对象：对给定对象加锁，进入同步代码前要获得给定对象的锁。
- 直接作用于实例方法：相当于对当前实例加锁，进入同步代码前要获得当前实例的锁。
- 直接作用于静态方法：相当于对当前类加锁，进入同步代码前要获得当前类的锁。

```
public static synchronized void increase(){
    i++;
}
```

除了用于线程同步、确保线程安全外，关键字synchronized还可以保证线程间的可见性和有序性。


