# GPM模型

- G：goroutine协程
- M：processor处理器
- P：thread线程
- 全局队列：存放等待运行的G
- P的本地的队列：存放等待运行的G；优先将新创建的G放在P的本地队列中，如果满了会放在全局队列中
- P列表：程序启动时创建；最多有GOMAXPROCS个（可配置）
- M列表：当前操作系统分配到当前Go程序的内核线程数
- P和M的数量：
    - P的数量问题：环境变量$GOMAXPROCS；在程序中通过runtime.GOMAXPROCS()来设置
    - M的数量问题：Go语言本身是限定M的最大量是10000（忽略）；runtime/debug包中的SetMaxThreads函数来设置；有一个M阻塞，会创建一个新的M；如果有M空闲，那么就会回收或者睡眠

## 多线程/进程问题
### 设计复杂
- 进程/线程的数量越多，切换成本就越大，也就越浪费。
- 多线程随着同步竞争（如锁、竞争资源冲突等）

### 多进程、线程壁垒
- 高内存占用
- 高CPU调度消耗

## 协程引发问题
### N:1
- 无法利用多个CPU
- 出现阻塞的瓶颈

### 1:1
- 跟多线程/多进程模型无异
- 切换协程成本代价昂贵

### M:N
- 能够利用多核
- 过于依赖协程调度器的优化和算法

## 调度器的优化

### Goroutine的优化

- 内存占用
- 灵活调度，切换成本低

### 早期的GO的调度器

基本的全局Go队列和比较传统的轮询利用多个Thread去调度

弊端
- 1、创建、销毁、调度G都需要每个M获取锁，这就形成了激烈的锁竞争
- 2、M转移G会造成延迟和额外的系统负载
- 3、系统调用（CPU在M之间的切换）导致频繁的线程阻塞和取消阻塞操作增加了系统开销