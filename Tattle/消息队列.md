# 消息队列对比

## 消息队列基础

### 什么是消息队列

消息队列是在消息的传输过程中保存消息的容器，用于接收消息并以文件的方式存储，一个消息队列可以被一个也可以被多个消费者消费，包含以下 3 元素：

- Producer：消息生产者，负责产生和发送消息到 Broker；
- Broker：消息处理中心，负责消息存储、确认、重试等，一般其中会包含多个 Queue；
- Consumer：消息消费者，负责从 Broker 中获取消息，并进行相应处理。

### 消息队列模式

- 点对点模式：多个生产者可以向同一个消息队列发送消息，一个具体的消息只能由一个消费者消费。
- 发布/订阅模式：单个消息可以被多个订阅者并发的获取和处理。

### 消息队列应用场景

- **应用解耦**：消息队列减少了服务之间的耦合性，不同的服务可以通过消息队列进行通信，而不用关心彼此的实现细节。
- **异步处理**：消息队列本身是异步的，它允许接收者在消息发送很长时间后再取回消息。
- **流量削锋**：当上下游系统处理能力存在差距的时候，利用消息队列做一个通用的”载体”，在下游有能力处理的时候，再进行分发与处理。
- **日志处理**：日志处理是指将消息队列用在日志处理中，比如 Kafka 的应用，解决大量日志传输的问题。
- **消息通讯**：消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯，比如实现点对点消息队列，或者聊天室等。
- **消息广播**：如果没有消息队列，每当一个新的业务方接入，我们都要接入一次新接口。有了消息队列，我们只需要关心消息是否送达了队列，至于谁希望订阅，是下游的事情，无疑极大地减少了开发和联调的工作量。

## 常用消息队列

### Kafka

Apache Kafka 最初由 LinkedIn 公司基于独特的设计实现为一个分布式的提交日志系统，之后成为 Apache 项目的一部分，**号称大数据的杀手锏，在数据采集、传输、存储的过程中发挥着举足轻重的作用。**

**它是一个分布式的，支持多分区、多副本，基于 Zookeeper 的分布式消息流平台**，它同时也是一款开源的基于发布订阅模式的消息引擎系统。

#### 重要概念

- **主题（Topic）**：消息的种类称为主题，可以说一个主题代表了一类消息，相当于是对消息进行分类，主题就像是数据库中的表。
- **分区（partition）**：主题可以被分为若干个分区，同一个主题中的分区可以不在一个机器上，有可能会部署在多个机器上，由此来实现 kafka 的伸缩性。
- **批次**：为了提高效率， 消息会分批次写入 Kafka，批次就代指的是一组消息。
- **消费者群组（Consumer Group）**：消费者群组指的就是由一个或多个消费者组成的群体。
- **Broker**: 一个独立的 Kafka 服务器就被称为 broker，broker 接收来自生产者的消息，为消息设置偏移量，并提交消息到磁盘保存。
- **Broker 集群**：broker 集群由一个或多个 broker 组成。
- **重平衡（Rebalance）**：消费者组内某个消费者实例挂掉后，其他消费者实例自动重新分配订阅主题分区的过程。

#### Kafka 架构

一个典型的 Kafka 集群中包含 Producer、broker、Consumer Group、Zookeeper 集群。

Kafka 通过 Zookeeper 管理集群配置，选举 leader，以及在 Consumer Group 发生变化时进行 rebalance。Producer 使用 push 模式将消息发布到 broker，Consumer 使用 pull 模式从 broker 订阅并消费消息。

### RocketMQ

RocketMQ 是阿里开源的消息中间件，它是纯 Java 开发，**具有高性能、高可靠、高实时、适合大规模分布式系统应用的特点。**

RocketMQ 思路起源于 Kafka，但并不是 Kafka 的一个 Copy，**它对消息的可靠传输及事务性做了优化**，目前在阿里集团被广泛应用于交易、充值、流计算、消息推送、日志流式处理、binglog 分发等场景。

#### 核心概念

- Broker：消息中转角色，负责存储消息，转发消息。Broker是具体提供业务的服务器，单个Broker节点与所有的NameServer节点保持长连接及心跳，并会定时将Topic信息注册到NameServer，顺带一提底层的通信和连接都是基于Netty实现的。Broker负责消息存储，以Topic为纬度支持轻量级的队列，单机可以支撑上万队列规模，支持消息推拉模型。官网上有数据显示：具有上亿级消息堆积能力，同时可严格保证消息的有序性。
- Topic：主题！它是消息的第一级类型。比如一个电商系统可以分为：交易消息、物流消息等，一条消息必须有一个 Topic 。Topic与生产者和消费者的关系非常松散，一个 Topic 可以有0个、1个、多个生产者向其发送消息，一个生产者也可以同时向不同的 Topic 发送消息。一个 Topic 也可以被 0个、1个、多个消费者订阅。
- Tag：标签！可以看作子主题，它是消息的第二级类型，用于为用户提供额外的灵活性。使用标签，同一业务模块不同目的的消息就可以用相同Topic而不同的Tag来标识。比如交易消息又可以分为：交易创建消息、交易完成消息等，一条消息可以没有Tag。标签有助于保持您的代码干净和连贯，并且还可以为RabbitMQ提供的查询系统提供帮助。
- MessageQueue：一个Topic下可以设置多个消息队列，发送消息时执行该消息的Topic，RocketMQ会轮询该Topic下的所有队列将消息发出去。消息的物理管理单位。一个Topic下可以有多个Queue，Queue的引入使得消息的存储可以分布式集群化，具有了水平扩展能力。
- NameServer：类似Kafka中的ZooKeeper，但NameServer集群之间是没有通信的，相对ZK来说更加轻量。它主要负责对于源数据的管理，包括了对于Topic和路由信息的管理。每个Broker在启动的时候会到NameServer注册，Producer在发送消息前会根据Topic去NameServer获取对应Broker的路由信息，Consumer也会定时获取 Topic 的路由信息。
- Producer：生产者，支持三种方式发送消息：同步、异步和单向单向发送 ：消息发出去后，可以继续发送下一条消息或执行业务代码，不等待服务器回应，且没有回调函数。异步发送 ：消息发出去后，可以继续发送下一条消息或执行业务代码，不等待服务器回应，有回调函数。同步发送 ：消息发出去后，等待服务器响应成功或失败，才能继续后面的操作。
- Consumer：消费者，支持 PUSH 和 PULL 两种消费模式，支持集群消费和广播消费集群消费 ：该模式下一个消费者集群共同消费一个主题的多个队列，一个队列只会被一个消费者消费，如果某个消费者挂掉，分组内其它消费者会接替挂掉的消费者继续消费。广播消费 ：会发给消费者组中的每一个消费者进行消费。相当于RabbitMQ的发布订阅模式。
- Group：分组，一个组可以订阅多个Topic。分为ProducerGroup，ConsumerGroup，代表某一类的生产者和消费者，一般来说同一个服务可以作为Group，同一个Group一般来说发送和消费的消息都是一样的
- Offset：在RocketMQ中，所有消息队列都是持久化，长度无限的数据结构，所谓长度无限是指队列中的每个存储单元都是定长，访问其中的存储单元使用Offset来访问，Offset为Java Long类型，64位，理论上在 100年内不会溢出，所以认为是长度无限。也可以认为Message Queue是一个长度无限的数组，Offset就是下标。

#### 重要概念

- **Name 服务器（NameServer）**：充当注册中心，类似 Kafka 中的 Zookeeper。
- **Broker**: 一个独立的 RocketMQ 服务器就被称为 broker，broker 接收来自生产者的消息，为消息设置偏移量。
- **主题（Topic）**：消息的第一级类型，一条消息必须有一个 Topic。
- **子主题（Tag）**：消息的第二级类型，同一业务模块不同目的的消息就可以用相同 Topic 和不同的 Tag 来标识。
- **分组（Group）**：一个组可以订阅多个 Topic，包括生产者组（Producer Group）和消费者组（Consumer Group）。
- **队列（Queue）**：可以类比 Kafka 的分区 Partition。

#### 延时消息

开源版的RocketMQ不支持任意时间精度，仅支持特定的level，例如定时5s，10s，1min等。其中，level=0级表示不延时，level=1表示1级延时，level=2表示2级延时，以此类推。

延时等级如下：

```
messageDelayLevel=1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h
```

#### 顺序消息

消息有序指的是可以按照消息的发送顺序来消费（FIFO）。RocketMQ可以严格的保证消息有序，可以分为 分区有序 或者 全局有序 。

#### 事务消息

消息队列MQ提供类似X/Open XA的分布式事务功能，通过消息队列MQ事务消息能达到分布式事务的最终一致。上图说明了事务消息的大致流程：正常事务消息的发送和提交、事务消息的补偿流程。

事务消息发送及提交：

- 发送half消息
- 服务端响应消息写入结果
- 根据发送结果执行本地事务（如果写入失败，此时half消息对业务不可见，本地逻辑不执行）；
- 根据本地事务状态执行Commit或Rollback（Commit操作生成消息索引，消息对消费者可见）。

事务消息的补偿流程：

- 对没有Commit/Rollback的事务消息（pending状态的消息），从服务端发起一次“回查”；
- Producer收到回查消息，检查回查消息对应的本地事务的状态。
- 根据本地事务状态，重新Commit或RollBack

其中，补偿阶段用于解决消息Commit或Rollback发生超时或者失败的情况。

事务消息状态：

事务消息共有三种状态：提交状态、回滚状态、中间状态：

- TransactionStatus.CommitTransaction：提交事务，它允许消费者消费此消息。
- TransactionStatus.RollbackTransaction：回滚事务，它代表该消息将被删除，不允许被消费。
- TransactionStatus.Unkonwn：中间状态，它代表需要检查消息队列来确定消息状态。

#### 死信队列

当一条消息消费失败，RocketMQ就会自动进行消息重试。而如果消息超过最大重试次数，RocketMQ就会认为这个消息有问题。但是此时，RocketMQ不会立刻将这个有问题的消息丢弃，而会将其发送到这个消费者组对应的一种特殊队列：死信队列。死信队列的名称是 %DLQ%+ConsumGroup 。

死信队列具有以下特性：

- 一个死信队列对应一个Group ID， 而不是对应单个消费者实例。
- 如果一个Group ID未产生死信消息，消息队列RocketMQ不会为其创建相应的死信队列。
- 一个死信队列包含了对应Group ID产生的所有死信消息，不论该消息属于哪个Topic。

#### RocketMQ工作原理

RockerMQ 中的消息模型就是按照主题模型所实现的，包括 Producer Group、Topic、Consumer Group 三个角色。

**为了提高并发能力，一个 Topic 包含多个 Queue**，生产者组根据主题将消息放入对应的 Topic，下图是采用轮询的方式找到里面的 Queue。

RockerMQ 中的消费群组和 Queue，可以类比 Kafka 中的消费群组和 Partition：**不同的消费者组互不干扰，一个 Queue 只能被一个消费者消费，一个消费者可以消费多个 Queue。**

消费 Queue 的过程中，通过偏移量记录消费的位置。

#### RocketMQ 架构

RocketMQ 技术架构中有四大角色 NameServer、Broker、Producer 和 Consumer，下面主要介绍 Broker。

**Broker 用于存放 Queue，一个 Broker 可以配置多个 Topic，一个 Topic 中存在多个 Queue。**

如果某个 Topic 消息量很大，应该给它多配置几个 Queue，并且尽量多分布在不同 broker 上，以减轻某个 broker 的压力。Topic 消息量都比较均匀的情况下，如果某个 broker 上的队列越多，则该 broker 压力越大。

### RabbitMQ

RabbitMQ 2007 年发布，是使用 Erlang 语言开发的开源消息队列系统，基于 AMQP 协议来实现。

AMQP 的主要特征是面向消息、队列、路由、可靠性、安全。**AMQP 协议更多用在企业系统内，对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在其次。**

#### 各组件功能

- Broker ：一个RabbitMQ实例就是一个Broker
- Virtual Host ：虚拟主机。相当于MySQL的DataBase，一个Broker上可以存在多个vhost，vhost之间相互隔离。每个vhost都拥有自己的队列、交换机、绑定和权限机制。vhost必须在连接时指定，默认的vhost是/。
- Exchange ：交换机，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。
- Queue ：消息队列，用来保存消息直到发送给消费者。它是消息的容器。一个消息可投入一个或多个队列。
- Banding ：绑定关系，用于消息队列和交换机之间的关联。通过路由键（Routing Key）将交换机和消息队列关联起来。- Channel ：管道，一条双向数据流通道。不管是发布消息、订阅队列还是接收消息，这些动作都是通过管道完成。因为对于操作系统来说，建立和销毁TCP都是非常昂贵的开销，所以引入了管道的概念，以复用一条TCP连接。
- Connection ：生产者/消费者 与broker之间的TCP连接。
- Publisher ：消息的生产者。
- Consumer ：消息的消费者。
- Message ：消息，它是由消息头和消息体组成。消息头则包括Routing-Key、Priority（优先级）等。

#### 交换机类型

Exchange 分发消息给 Queue 时， Exchange 的类型对应不同的分发策略，有3种类型的 Exchange ：Direct、Fanout、Topic。

- Direct：消息中的 Routing Key 如果和 Binding 中的 Routing Key 完全一致， Exchange 就会将消息分发到对应的队列中。
- Fanout：每个发到 Fanout 类型交换机的消息都会分发到所有绑定的队列上去。Fanout交换机没有 Routing Key 。它在三种类型的交换机中转发消息是最快的。
- Topic：Topic交换机通过模式匹配分配消息，将 Routing Key 和某个模式进行匹配。它只能识别两个通配符："#"和"*"。### 匹配0个或多个单词， * 匹配1个单词。

#### TTL

TTL（Time To Live）：生存时间。RabbitMQ支持消息的过期时间，一共2种。

- 在消息发送时进行指定。通过配置消息体的 Properties ，可以指定当前消息的过期时间。
- 在创建Exchange时指定。从进入消息队列开始计算，只要超过了队列的超时时间配置，那么消息会自动清除。

#### 生产者的消息确认机制

Confirm机制：

- 消息的确认，是指生产者投递消息后，如果Broker收到消息，则会给我们生产者一个应答。
- 生产者进行接受应答，用来确认这条消息是否正常的发送到了Broker，这种方式也是消息的可靠性投递的核心保障！

如何实现Confirm确认消息？

- 在channel上开启确认模式：channel.confirmSelect()
- 在channel上开启监听：addConfirmListener ，监听成功和失败的处理结果，根据具体的结果对消息进行重新发送或记录日志处理等后续操作。

Return消息机制：

Return Listener用于处理一些不可路由的消息。

我们的消息生产者，通过指定一个Exchange和Routing，把消息送达到某一个队列中去，然后我们的消费者监听队列进行消息的消费处理操作。

但是在某些情况下，如果我们在发送消息的时候，当前的exchange不存在或者指定的路由key路由不到，这个时候我们需要监听这种不可达消息，就需要使用到Returrn Listener。

基础API中有个关键的配置项 Mandatory ：如果为true，监听器会收到路由不可达的消息，然后进行处理。如果为false，broker端会自动删除该消息。

同样，通过监听的方式， chennel.addReturnListener(ReturnListener rl) 传入已经重写过handleReturn方法的ReturnListener。

#### 消费端ACK与NACK

消费端进行消费的时候，如果由于业务异常可以进行日志的记录，然后进行补偿。但是对于服务器宕机等严重问题，我们需要手动ACK保障消费端消费成功。

```
// deliveryTag：消息在mq中的唯一标识

// multiple：是否批量(和qos设置类似的参数)

// requeue：是否需要重回队列。或者丢弃或者重回队首再次消费。

public void basicNack(long deliveryTag, boolean multiple, boolean requeue) 
```

如上代码，消息在消费端重回队列是为了对没有成功处理消息，把消息重新返回到Broker。一般来说，实际应用中都会关闭重回队列（避免进入死循环），也就是设置为false。

#### 死信队列DLX

死信队列（DLX Dead-Letter-Exchange）：当消息在一个队列中变成死信之后，它会被重新推送到另一个队列，这个队列就是死信队列。

DLX也是一个正常的Exchange，和一般的Exchange没有区别，它能在任何的队列上被指定，实际上就是设置某个队列的属性。

当这个队列中有死信时，RabbitMQ就会自动的将这个消息重新发布到设置的Exchange上去，进而被路由到另一个队列。

#### 重要概念

- **信道（Channel）**：消息读写等操作在信道中进行，客户端可以建立多个信道，每个信道代表一个会话任务。
- **交换器（Exchange）**：接收消息，按照路由规则将消息路由到一个或者多个队列；如果路由不到，或者返回给生产者，或者直接丢弃。
- **路由键（RoutingKey）**：生产者将消息发送给交换器的时候，会发送一个 RoutingKey，用来指定路由规则，这样交换器就知道把消息发送到哪个队列。
- **绑定（Binding）**：交换器和消息队列之间的虚拟连接，绑定中可以包含一个或者多个 RoutingKey。

#### RabbitMQ工作原理

AMQP 协议模型由三部分组成：生产者、消费者和服务端，执行流程如下：

1. 生产者是连接到 Server，建立一个连接，开启一个信道。

2. 生产者声明交换器和队列，设置相关属性，并通过路由键将交换器和队列进行绑定。

3. 消费者也需要进行建立连接，开启信道等操作，便于接收消息。

4. 生产者发送消息，发送到服务端中的虚拟主机。

5. 虚拟主机中的交换器根据路由键选择路由规则，发送到不同的消息队列中。

6. 订阅了消息队列的消费者就可以获取到消息，进行消费。

## 消息队列对比

Kafka

**优点：**

- **高吞吐、低延迟**：Kafka 最大的特点就是收发消息非常快，Kafka 每秒可以处理几十万条消息，它的最低延迟只有几毫秒；
- **高伸缩性**：每个主题（topic）包含多个分区（partition），主题中的分区可以分布在不同的主机（broker）中；
- **高稳定性**：Kafka 是分布式的，一个数据多个副本，某个节点宕机，Kafka 集群能够正常工作；
- **持久性、可靠性、可回溯**：Kafka 能够允许数据的持久化存储，消息被持久化到磁盘，并支持数据备份防止数据丢失，支持消息回溯；
- 消息有序：通过控制能够保证所有消息被消费且仅被消费一次；
- 有优秀的第三方 Kafka Web 管理界面 Kafka-Manager，在日志领域比较成熟，被多家公司和多个开源项目使用。

**缺点：**

- Kafka 单机超过 64 个队列/分区，Load 会发生明显的飙高现象，队列越多，load 越高，发送消息响应时间变长；
- **不支持消息路由，不支持延迟发送，不支持消息重试；**
- **社区更新较慢。**

### RocketMQ

**优点：**

- **高吞吐**：借鉴 Kafka 的设计，单一队列百万消息的堆积能力；
- **高伸缩性**：灵活的分布式横向扩展部署架构，整体架构其实和 kafka 很像；
- **高容错性**：通过ACK机制，保证消息一定能正常消费；
- **持久化、可回溯**：消息可以持久化到磁盘中，支持消息回溯；
- 消息有序：在一个队列中可靠的先进先出（FIFO）和严格的顺序传递；
- 支持发布/订阅和点对点消息模型，支持拉、推两种消息模式；
- 提供 docker 镜像用于隔离测试和云集群部署，提供配置、指标和监控等功能丰富的 Dashboard。

**缺点：**

- 不支持消息路由，**支持的客户端语言不多，目前是 java 及 c++，其中 c++ 不成熟**；
- 部分支持消息有序：需要将同一类的消息 hash 到同一个队列 Queue 中，才能支持消息的顺序，如果同一类消息散落到不同的 Queue中，就不能支持消息的顺序。

- **社区活跃度一般。**

### RabbitMQ

**优点：**

- **支持几乎所有最受欢迎的编程语言**：Java，C，C ++，C＃，Ruby，Perl，Python，PHP等等；
- **支持消息路由**：RabbitMQ 可以通过不同的交换器支持不同种类的消息路由；
- **消息时序**：通过延时队列，可以指定消息的延时时间，过期时间TTL等；
- 支持容错处理：通过交付重试和死信交换器（DLX）来处理消息处理故障；
- 提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker；
- **社区活跃度高。**

**缺点：**

- **Erlang 开发，很难去看懂源码，不利于做二次开发和维护**，基本职能依赖于开源社区的快速维护和修复 bug；
- **RabbitMQ 吞吐量会低一些**，这是因为他做的实现机制比较重；
- 不支持消息有序、持久化不好、不支持消息回溯、伸缩性一般。

## 消息队列选型

- Kafka：追求高吞吐量，一开始的目的就是用于日志收集和传输，**适合产生大量数据的互联网服务的数据收集业务**，大型公司建议可以选用，**如果有日志采集功能，肯定是首选 kafka。**
- RocketMQ：**天生为金融互联网领域而生，对于可靠性要求很高的场景**，尤其是电商里面的订单扣款，以及业务削峰，在大量交易涌入时，后端可能无法及时处理的情况。RoketMQ 在稳定性上可能更值得信赖，这些业务场景在阿里双 11 已经经历了多次考验，**如果你的业务有上述并发场景，建议可以选择 RocketMQ。**
- RabbitMQ：结合 erlang 语言本身的并发优势，性能较好，社区活跃度也比较高，但是不利于做二次开发和维护，不过 RabbitMQ 的社区十分活跃，可以解决开发过程中遇到的 bug。**如果你的数据量没有那么大，小公司优先选择功能比较完备的 RabbitMQ。**
- ActiveMQ：官方社区现在对 ActiveMQ 5.x 维护越来越少，**较少在大规模吞吐的场景中使用。**
