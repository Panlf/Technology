# 优化接口的方式

## 批量思想

### 批量操作数据库

`batchInsert`

## 索引

SQL语句的字段索引

- 没有加索引
- 索引没有生效 explain
- 选错索引
- sql优化

索引失效的常见原因
- 不满足最左前缀原则
- 范围索引列没有放最后
- 使用了select *
- 索引列上有计算
- 索引列上使用了函数
- 字符类型没加引号
- 用is null和is not null没注意字段是否允许为空
- like查询左边有%
- 使用or关键字时没有注意

## SQL优化

sql优化的15个小技巧
- 避免使用select *
- 用union all代替union
- 小表驱动大表
- 批量操作
- 多用limit
- in中值太多
- 增量查询
- 高效的分页
- 用连接查询代替子查询
- join的表不宜过多
- join时要注意
- 控制索引的数量
- 选择合理的字段类型
- 提升group by的效率
- 索引优化

## 远程调用

### 并行调用

CompleteFuture类可以实现

### 数据异构

数据冗余，注意数据一致性问题。

## 重复调用

- 循环查数据库
- 死循环
- 无限递归

## 异步处理

耗时操作，可以考虑异步处理。

- 核心逻辑可以使用同步调用
- 非核心逻辑可以考虑异步调用，异步调库
- 线程池


## 避免大事务

大事务引发的问题
- 死锁
- 回滚时间长
- 并发情况下数据库连接池被占满
- 锁等待
- 接口超时
- 数据库主从延迟

## 锁粒度

### 数据库锁

- 表锁 ：加锁快，不会出现死锁但是锁的粒度大，发生锁冲突的概率最高，并发度最低。
- 行锁 ：加锁慢，会出现死锁但是锁的粒度小，发生锁冲突的概率最低，并发度也最高。
- 间隙锁 ：开销和加锁时间介于表锁和行锁之间，它会出现死锁，锁的粒度介于表锁和行锁之间。并发度一般。

## 分页处理

批次查询，CompleteFuture并发查询。

## 空间换时间思想：加缓存

- JVM本地缓存
- redis缓存
- 基于内存的缓存 Map

## 预取思想：提前初始化到缓存

提前把要计算查询的数据，初始化到缓存。

## 池化思想：预分配与循环使用
- 线程池
- 数据库连接池
- HttpClient连接池
- Keep-Alive长连接

## 事件回调思想：拒绝阻塞等待

参考IO多路复用模型。等接口处理完，通过事件回调通知，我们接口收到通知再进行对应的业务操作即可。

## 分库分表

## 深分页

limit 100000,10

- 标签记录法
- 延迟关联法

## 切换存储方式：文件中转暂存数据

可以考虑先用文件的方式暂存，再异步慢慢保存到数据库。        

## 压缩传输内容

压缩传输内容，传输报文变得更小，因此传输会更快了。

## 机器问题

fullGC、线程打满、太多IO资源没关闭等等

## 辅助功能

- 开启慢查询日志
- 监控 Prometheus
